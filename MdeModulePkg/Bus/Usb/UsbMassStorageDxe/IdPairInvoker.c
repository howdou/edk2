/**
  DO NOT EDIT
  This file is auto-generated by uefi-aware compiler toolchain
  Contact steven.shi@intel.com for more details
**/
#include <Uefi.h>
#include "AutoGen.h"
#include "UsbMass.h"
#include <Library/BaseLib.h>
#include <Library/DebugLib.h>
#include <Library/UefiBootServicesTableLib.h>
#include <Library/UefiDriverEntryPoint.h>

// Only support one CBI protocol instance for now
static  USB_CBI_PROTOCOL     *UsbCbiTrace = NULL;

EFI_STATUS
UsbCbi_IdPairTrace (
  IN  EFI_USB_IO_PROTOCOL   *UsbIo,
  OUT USB_CBI_PROTOCOL      **Trace       OPTIONAL
  )
{
  EFI_USB_INTERFACE_DESCRIPTOR  *Interface;
  EFI_USB_ENDPOINT_DESCRIPTOR   EndPoint;
  EFI_STATUS                    Status;
  UINT8                         Index;
  USB_CBI_PROTOCOL              *UsbCbi;
  //
  // Allocate the CBI context for USB_CBI_PROTOCOL and 3 endpoint descriptors.
  //
  UsbCbi = AllocateZeroPool (
             sizeof (USB_CBI_PROTOCOL) + 3 * sizeof (EFI_USB_ENDPOINT_DESCRIPTOR)
             );
  ASSERT (UsbCbi != NULL);

  UsbCbi->UsbIo = UsbIo;

  //
  // Get the interface descriptor and validate that it
  // is a USB Mass Storage CBI interface.
  //
  Status = UsbIo->UsbGetInterfaceDescriptor (UsbIo, &UsbCbi->Interface);
  if (EFI_ERROR (Status)) {
    goto ON_ERROR;
  }

  Interface = &UsbCbi->Interface;

  //
  // Locate and save the bulk-in, bulk-out, and interrupt endpoint
  //
  for (Index = 0; Index < Interface->NumEndpoints; Index++) {
    Status = UsbIo->UsbGetEndpointDescriptor (UsbIo, Index, &EndPoint);
    if (EFI_ERROR (Status)) {
      continue;
    }

    if (USB_IS_BULK_ENDPOINT (EndPoint.Attributes)) {
      //
      // Use the first Bulk-In and Bulk-Out endpoints
      //
      if (USB_IS_IN_ENDPOINT (EndPoint.EndpointAddress) &&
         (UsbCbi->BulkInEndpoint == NULL)) {

        UsbCbi->BulkInEndpoint  = (EFI_USB_ENDPOINT_DESCRIPTOR *) (UsbCbi + 1);
        CopyMem(UsbCbi->BulkInEndpoint, &EndPoint, sizeof (EndPoint));;
      }

      if (USB_IS_OUT_ENDPOINT (EndPoint.EndpointAddress) &&
         (UsbCbi->BulkOutEndpoint == NULL)) {

        UsbCbi->BulkOutEndpoint   = (EFI_USB_ENDPOINT_DESCRIPTOR *) (UsbCbi + 1) + 1;
        CopyMem(UsbCbi->BulkOutEndpoint, &EndPoint, sizeof (EndPoint));
      }
    } else if (USB_IS_INTERRUPT_ENDPOINT (EndPoint.Attributes)) {
      //
      // Use the first interrupt endpoint if it is CBI0
      //
      if ((Interface->InterfaceProtocol == USB_MASS_STORE_CBI0) &&
          (UsbCbi->InterruptEndpoint == NULL)) {

        UsbCbi->InterruptEndpoint   = (EFI_USB_ENDPOINT_DESCRIPTOR *) (UsbCbi + 1) + 2;
        CopyMem(UsbCbi->InterruptEndpoint, &EndPoint, sizeof (EndPoint));
      }
    }
  }

  if (Trace != NULL && *Trace != NULL ){
    *Trace = UsbCbi;
  }

  UsbCbiTrace = UsbCbi;
  return EFI_SUCCESS;

ON_ERROR:
  if (UsbCbi != NULL) {
    FreePool (UsbCbi);
    if (Trace != NULL && *Trace != NULL ){
      *Trace = NULL;
    }
  }
  return Status;
}

EFI_STATUS
UsbCbiSendCommand (
  IN USB_CBI_PROTOCOL       *UsbCbi,
  IN UINT8                  *Cmd,
  IN UINT8                  CmdLen,
  IN UINT32                 Timeout
  );

EFI_STATUS
UsbCbiSendCommand_Invoker (
  IN UINT8                  *Cmd,
  IN UINT8                  CmdLen
  )
{
  //
  // Multiplex UsbIO
  //
  UINT32                 Timeout;
  EFI_STATUS             Status;

  if (UsbCbiTrace == NULL){
    return EFI_UNSUPPORTED;
  }

  Timeout = 100 * USB_MASS_1_MILLISECOND;
  Status = UsbCbiSendCommand (
                UsbCbiTrace,
                Cmd,
                CmdLen,
                Timeout
                );
  return Status;
}

EFI_STATUS
UsbCbiDataTransfer (
  IN USB_CBI_PROTOCOL         *UsbCbi,
  IN EFI_USB_DATA_DIRECTION   DataDir,
  IN OUT UINT8                *Data,
  IN OUT UINTN                *TransLen,
  IN UINT32                   Timeout
  );

EFI_STATUS
UsbCbiDataTransfer_Invoker (
  IN EFI_USB_DATA_DIRECTION   DataDir,
  IN OUT UINT8                *Data,
  IN OUT UINTN                *TransLen
  )
{
  //
  // Multiplex UsbIO
  //
  UINT32                 Timeout;
  EFI_STATUS             Status;

  if (UsbCbiTrace == NULL){
    return EFI_UNSUPPORTED;
  }

  Timeout = 100 * USB_MASS_1_MILLISECOND;
  Status = UsbCbiDataTransfer (
                UsbCbiTrace,
                DataDir,
                Data,
                TransLen,
                Timeout
                );
  return Status;
}

EFI_STATUS
UsbCbiGetStatus (
  IN  USB_CBI_PROTOCOL        *UsbCbi,
  IN  UINT32                  Timeout,
  OUT USB_CBI_STATUS          *Result
  );

EFI_STATUS
UsbCbiGetStatus_Invoker (
  OUT USB_CBI_STATUS          *Result
  )
{
  //
  // Multiplex UsbIO
  //
  UINT32                 Timeout;
  EFI_STATUS             Status;

  if (UsbCbiTrace == NULL){
    return EFI_UNSUPPORTED;
  }

  Timeout = 100 * USB_MASS_1_MILLISECOND;
  Status = UsbCbiGetStatus (
                UsbCbiTrace,
                Timeout,
                Result
                );
  return Status;
}
