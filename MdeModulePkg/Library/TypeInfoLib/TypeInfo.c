/** @file
  This TypeInfoList[] array contains all the type info of a module's interface.
  e.g. protocal interface structure fields detail info as below:
  //
  //TYPE:EFI_SIMPLE_TEXT_INPUT_PROTOCOL
  //
  typedef struct _TYPE__EFI_SIMPLE_TEXT_INPUT_PROTOCOL{
    const CHAR8* TypeName;
    const UINTN TypeClass;
    const UINTN TypeSize;
    const UINTN StructFieldNum;
    const CHAR8* StructFieldName_1;
    const CHAR8* StructFieldTypeName_1;
    const CHAR8* StructFieldName_2;
    const CHAR8* StructFieldTypeName_2;
    const CHAR8* StructFieldName_3;
    const CHAR8* StructFieldTypeName_3;
  } TYPE__EFI_SIMPLE_TEXT_INPUT_PROTOCOL;

  TYPE__EFI_SIMPLE_TEXT_INPUT_PROTOCOL TypeInfo__EFI_SIMPLE_TEXT_INPUT_PROTOCOL = {
    .TypeName = "EFI_SIMPLE_TEXT_INPUT_PROTOCOL",
    .TypeClass = Structure,
    .TypeSize = sizeof(EFI_SIMPLE_TEXT_INPUT_PROTOCOL),
    .StructFieldNum = 3,
    .StructFieldName_1 = "Reset",
    .StructFieldTypeName_1 = "EFI_INPUT_RESET",
    .StructFieldName_2 = "ReadKeyStroke",
    .StructFieldTypeName_2 = "EFI_INPUT_READ_KEY",
    .StructFieldName_3 = "WaitForKey",
    .StructFieldTypeName_3 = "EFI_EVENT"
  };

  This TypeInfoList[] is auto generated by a Uefi-aware compiler during 
  normal build, and its name is hardcoded and fixed.

  Copyright (c) 2018, Intel Corporation. All rights reserved.<BR>
  This program and the accompanying materials
  are licensed and made available under the terms and conditions of the BSD License
  which accompanies this distribution.  The full text of the license may be found at
  http://opensource.org/licenses/bsd-license.php.

  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.

**/


#include <Uefi.h>
#include <Library/UefiBootServicesTableLib.h>
#include <Protocol/TypeInfo.h>
#include <Library/DebugLib.h>
#include <Library/UefiDriverEntryPoint.h>

extern void *TypeInfoList[];

EFI_STATUS
EFIAPI
TypeInfo_ModuleEntryPoint (
  IN EFI_HANDLE        ImageHandle,
  IN EFI_SYSTEM_TABLE  *SystemTable
  )
{
  ProcessLibraryConstructorList (ImageHandle, SystemTable);
  DEBUG ((EFI_D_ERROR, "TypeInfo_ModuleEntryPoint done\n"));
  return RETURN_SUCCESS;
}


RETURN_STATUS
EFIAPI
TypeInfoLibConstructor (
  IN EFI_HANDLE        ImageHandle,
  IN EFI_SYSTEM_TABLE  *SystemTable
  )
{
  EFI_STATUS                    Status;
  //VOID                          *Ptr;

  Status = RETURN_SUCCESS;

  if (TypeInfoList != NULL && TypeInfoList[0] != NULL){
    // DEBUG ((EFI_D_ERROR, "TypeInfoList= 0x%x\n",TypeInfoList));
    // UINTN  Index = 0;
    // TYPE_INFO_HEADER  *TypeInfoPtr;
    // while (TypeInfoList[Index] != NULL ){
      // DEBUG ((EFI_D_ERROR, "TypeInfoList[%d]= 0x%x\n", Index, TypeInfoList[Index]));
      // TypeInfoPtr = (TYPE_INFO_HEADER *)TypeInfoList[Index];
      // DEBUG ((EFI_D_ERROR, "TypeClass= 0x%x\n", TypeInfoPtr->TypeClass));
      // DEBUG ((EFI_D_ERROR, "TypeSize= 0x%x\n", TypeInfoPtr->TypeSize));
      // DEBUG ((EFI_D_ERROR, "TypeName= %a\n", TypeInfoPtr->TypeName));
      // switch (TypeInfoPtr->TypeClass){
        // case TYPE_CLASS_PROTOCOL:
          // Ptr = (void *)(TypeInfoPtr + 1);
          // DEBUG ((EFI_D_ERROR, "ProtocolGuid= %g\n", *(GUID **)Ptr));
          // Ptr = Ptr + sizeof(GUID*);
          // DEBUG ((EFI_D_ERROR, "InterfaceStructName= %a\n", *(CHAR8 **)Ptr));
        // default:
          // ;
      // }

      // Index++;
    // }

    Status = gBS->InstallProtocolInterface (
                    &ImageHandle,
                    &gInterfaceTypeInfoProtocolGuid,
                    EFI_NATIVE_INTERFACE,
                    &TypeInfoList
                    );
  }
  return Status;
}


RETURN_STATUS
EFIAPI
TypeInfoLibDestructor (
  IN EFI_HANDLE        ImageHandle,
  IN EFI_SYSTEM_TABLE  *SystemTable
  )
{
  EFI_STATUS                    Status;
  VOID                          *Interface;

  Status = gBS->HandleProtocol(
                  ImageHandle,
                  &gInterfaceTypeInfoProtocolGuid,
                  (VOID **) &Interface
                  );
  if (!EFI_ERROR (Status)) {
    Status = gBS->UninstallProtocolInterface(
                    ImageHandle,
                    &gInterfaceTypeInfoProtocolGuid,
                    Interface
                    );
  }

  return RETURN_SUCCESS;
}